# LogicSimulator
C++で論理回路を作ってシミュレーションするサンプルです。
LogicParts.cppをコンパイルし、LogicParts.hをインクルードして使用してください。
本ライブラリはC++11以降の記法を想定しています。

## 概要
論理回路のシミュレーションをプログラミングで行うための支援ライブラリです。
単に論理演算を行うだけであれば、論理計算式を直接書き込めば計算可能ですが、
本ライブラリでは素子を組み合わせて論理回路部品を作っておき、
それぞれを接続して大きな論理回路を作ってシミュレーションを行うことに向いています。
また、計算式の記述だけでは実装出来ないフリップフロップ等の順序回路の実装も可能です。
論理回路の学習教材にも有用です。

本ライブラリでは直観的かつ簡潔な記述によって論理回路の構築及びシミュレーションを行うことが可能です。

## 使い方例
論理回路の設計は直観的に行うことが可能です。
以下は端子A, Bをそれぞれ定義し、端子CをAnd(Or(A, B), Nand(A, B))として定義している例です。
A, Bに値（true(1)またはfalse(0)）をセットすると、Cからは演算結果（これはXorの回路です）を取得できます。

```cpp
auto A = Terminal();
auto B = Terminal();
auto C = And(Or(A, B), Nand(A, B));

A->set(0); B->set(0); cout << C->get() << endl;
A->set(0); B->set(1); cout << C->get() << endl;
A->set(1); B->set(0); cout << C->get() << endl;
A->set(1); B->set(1); cout << C->get() << endl;
```

```cpp
[結果]
0
1
1
0
```

## 論理回路演算の仕組み
LogicParts.hで定義されているLogicParts::BasePartsクラスがすべての素子の基本クラスとなります。
各素子はinputに入力端子のポインタを保持しており、get関数によりすべての入力端子をたどって演算を行います。
フリップフロップのように入力端子が循環している場合は、一度のget関数で参照した素子は前回値を採用するというルールで計算します。
入力値を持つ端子は_Terminalクラスであり、Terminal関数によってインスタンスを生成します。
その他の基本素子は論理演算を行った結果を返却します。

LogicComposite.cppは基本素子を組み合わせて作った論理回路部品（加算器など）をまとめたものであり、
Products.cppではさらにそれらを組み合わせて単体の製品として作成したものをまとめてあります。
新たに部品を作成する際には、LogicComposite.cppまたはProducts.cppに関数として追加してください。

## サンプルについて
Sample.cppでは、LogicPartsを用いたサンプルをまとめてあります。
実際に論理回路を作成するコード例を確認できます。
